<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>HTML 5 Canvas Test</title>
</head>
<body style="margin: 0; padding: 0; height: 100%"
      onkeydown="keyEvent(event)">

<div id="drawing_container"
     style="margin: 0px auto; width: 6in; height: 5in; min-height: 100%; border-style: solid; border-color: black; overflow: hidden"
     onmousedown="if (!rotating) rotating = window.setTimeout(periodic_render, 10); else rotating = 0;">
  <canvas id="drawing_pad" width="1" height="1" />
</div>

<script>
  var canvas = document.getElementById('drawing_pad');
  var c = canvas.getContext('2d');
  var ec;
  var src_data;
    /* longitude rotation */
    var lon_rot = 85;
    /* globe tilt */
    var tilt = 45;
    /* globe scale */
    var scale = 1.0;
    var rotating = 0;
  var container = document.getElementById('drawing_container');
  // Resize canvas to fit CSS allocated space.
  // Warning: clientWidth and clientHeight marked as unstable in MDN.
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  /* window.innerWidth, window.innerHeight */

  // Create a backbuffer canvas to pull pixels from.
  var earth_buffer = document.createElement('canvas');
  earth_buffer.id = 'earth_buffer';

  // NOTE: Verify if HTML 5 style image loading works with IE6.

  { // WARNING: Large image loading is slow.
    var earth_tex = new Image();
    earth_tex.onload = function () {
      earth_buffer.width = earth_tex.width;
      earth_buffer.height = earth_tex.height;
      ec = earth_buffer.getContext('2d');
      ec.drawImage(earth_tex, 0, 0);

      try {
        src_data = ec.getImageData(0, 0, earth_buffer.width,
          earth_buffer.height);
      } catch (e) {
        alert('Error: Cannot read pixels from image buffer.');
        throw new Error("unable to access image data: " + e);
      }

      render_globe();
    }
    // earth_tex.src = "Equirectangular_projection_SW.png";
    earth_tex.src = "test_grs2rgb.png";
  }

// TODO: This function should be a tile-based rendering engine that
// gets called from a callback to complete the render.  In general,
// JavaScript cannot support threads.
function render_globe() {
  { // Project and render the image.
    var dest_data = c.createImageData(canvas.width, canvas.height);
    var dest_index = 0;
    var y_center = dest_data.height / 2;
    var x_center = dest_data.width / 2;
    /* display radius */
    var disp_rad = Math.min(dest_data.height, dest_data.width) * scale / 2.0;
    for (var y = 0; y < dest_data.height; y++) {
      for (var x = 0; x < dest_data.width; x++) {
        /* 1. Get the 3D rectangular coordinate of the ray intersection
              with the sphere.  The camera is looking down the negative
              z axis.  */
        var r3src_x; var r3src_y; var r3src_z;
        r3src_y = (y - y_center) / disp_rad;
        r3src_x = (x - x_center) / disp_rad;
        r3src_z = Math.sin(Math.acos(Math.sqrt(Math.pow(r3src_x, 2) +
                                      Math.pow(r3src_y, 2))));

        /* 2. Inverse rotate this coordinate around the x axis by the
              current globe tilt.  */
        var i_tilt = -tilt * Math.PI / 180;
        var cos_tilt = Math.cos(i_tilt); var sin_tilt = Math.sin(i_tilt);
        var r3dest_x; var r3dest_y; var r3dest_z;
        r3dest_x = r3src_x;
        r3dest_z = r3src_z * cos_tilt - r3src_y * sin_tilt;
        r3dest_y = r3src_z * sin_tilt + r3src_y * cos_tilt;

        /* 3. Measure the latitude and longitude of this coordinate.  */
        var latitude = Math.asin(r3dest_y);
        var longitude = Math.atan2(r3dest_x, r3dest_z);

        /* 4. Convert from radians to degrees.  */
        latitude = latitude * 180 / Math.PI;
        longitude = longitude * 180 / Math.PI;

        /* 5. Inverse shift by the longitudinal rotation around the pole.  */
        longitude += lon_rot;

        /* 6. Verify that the coordinates are in bounds.  */
        latitude += 90;
        if (latitude < 0) latitude = 0;
        if (latitude > 180) latitude = 180;
        while (longitude < 0) {
          longitude += 360;
        }
        while (longitude >= 360) {
          longitude -= 360;
        }

        if (!isNaN(latitude) && !isNaN(longitude)) {
          var src_y = ~~(latitude * src_data.height / 180);
          var src_x = ~~(longitude * src_data.width / 360);
          if (src_y == src_data.height)
            src_y -= 1;
          var src_index = (src_data.width * src_y + src_x) * 4;
          dest_data.data[dest_index++] = src_data.data[src_index++];
          dest_data.data[dest_index++] = src_data.data[src_index++];
          dest_data.data[dest_index++] = src_data.data[src_index++];
          dest_data.data[dest_index++] = 255;
          continue;
        } else {
          dest_data.data[dest_index++] = 255;
          dest_data.data[dest_index++] = 0;
          dest_data.data[dest_index++] = 0;
          dest_data.data[dest_index++] = 255;
        }
      }
    }
    c.putImageData(dest_data, 0, 0);
  }
}

function periodic_render() {
  if (!rotating)
    return;
  lon_rot += 5;
  render_globe();
  if (rotating)
    return rotating = setTimeout(periodic_render, 10);
}

function keyEvent (event) {
  /* if (event.defaultPrevented) {
    return; // Should do nothing if the key event was already consumed.
  } */

  switch (event.code) {
    case "KeyA":
      lon_rot -= 5;
      break;
    case "KeyD":
      lon_rot += 5;
      break;
    case "KeyS":
      lat_rot -= 5;
      break;
    case "KeyW":
      lat_rot += 5;
      break;
    default:
      return;
  }

  render_globe();
}

/* //create a new 300 x 300 pixel buffer
var data = c.createImageData(300,200);

//loop over every pixel
for(var x=0; x < data.width; x++) {
    for(var y=0; y < data.height; y++) {
        
        var val = 0;
        var horz = (Math.floor(x/4) % 2 == 0); //loop every 4 pixels
        var vert = (Math.floor(y/4) % 2 == 0); // loop every 4 pixels
        if( (horz && !vert) || (!horz && vert)) {
            val = 255;
        } else {
            val = 0;
        }
        
        var index = (y*data.width+x)*4;  //calculate index
        data.data[index] = val;   // red
        data.data[index+1] = val; // green
        data.data[index+2] = val; // blue
        data.data[index+3] = 255; // force alpha to 100%
    }
}
//set the data back
c.putImageData(data,0,0); */


  /* c.beginPath();
  c.fillStyle = "#aaffaa";
  c.strokeStyle = "#ff0000";
  c.lineCap = "round";
  c.lineJoin = "round";
  c.lineWidth = 15;
  c.fillRect(0, 0, canvas.width, canvas.height);
  c.moveTo(32, 32);
  c.lineTo(canvas.width - 32, canvas.height - 32);
  c.lineTo(canvas.width / 2, 32);
  c.stroke(); */
</script>

</body>
</html>
