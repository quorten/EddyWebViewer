<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>wchar test page</title>
  <style type="text/css">
    #daCntr { height: 400px; overflow: auto; border-style: solid;
              margin: 8px; padding: 8px; }
  </style>
</head>
<body>

<p>This is the wchar test page.  Good luck!</p>

<div id="daCntr"></div>

<script type="text/javascript" src="../libs/mylib.js"></script>
<script type="text/javascript">
<!--//--><![CDATA[//><!--

var httpRequest;

var textBuf;
// The character code that represents zero in the input.
var INPUT_ZERO_SYM;
var eddiesPerDate = [];
var dateChunkStarts = [];
var startOfData; // Character offset where eddy records begin.

var body; // = API.getBodyElement();
var daCntr = document.getElementById('daCntr');
var kdDbg;
var exampleVboxes = [
  [ 40, -170, 50, -160 ],
  [ -40, -170, 50, -160 ],
  [ 0, -170, 50, -130 ],
  [ -50, -20, -30, 20 ],
  [ -50, -20, 0, 20 ],
  [ 30, 45, 50, 60 ],
  [ 30, 75, 50, 90 ],
  [ -50, -140, 0, -100 ],
  [ -65, -100, -15, -60 ],
  [ -70, -120, 70, 120 ],
  [ -70, -70, 70, 70 ],
  [ -20, 160, 20, -160 ] ];
var binDisplay;
var genSLink;

/*

http://stackoverflow.com/questions/654112/how-do-you-detect-support-for-vml-or-svg-in-a-browser

Array of date records:

[ list of downloaded chunk starts ]
[ list of data strings ]

First request: download linearly.

User seeks to an undownloaded position: abort current request.
Start new request (insert new request chunk)
Download a couple of date indexes in front of request for performance
Keep downloading
When finished, download any missing chunks in between
Always start download at date boundary.

Provision for a time where backwards downloads are requested before
normal downloads.

*/

// Display an object as text for diagnostics.
function dispDiag(diagText) {
  var dispInfo = document.createElement("pre");
  dispInfo.appendChild(document.createTextNode(diagText));
  body.appendChild(dispInfo);
}

// Display an array with brackets bounding the edges.
function dispArray(array) {
  var length = array.length;
  var diagText = "" + length + ": [ " + array + " ]";
  diagText = diagText.replace(/,/g, ", ");
  var wrapper = document.createElement("p");
  var dispInfo = document.createElement("code");
  dispInfo.appendChild(document.createTextNode(diagText));
  wrapper.appendChild(dispInfo);
  daCntr.appendChild(wrapper);
  // if (array[i].constructor == Array) recurse
}

/* Compute the byte range to download for the given date index.  */
function getDate(outRange, index) {
  var eddyIndex = dateChunkStarts[index];
  var numNls = 0|(eddyIndex / 32);
  outRange[0] = startOfData + eddyIndex * 4 + numNls;
  eddyIndex = dateChunkStarts[index+1];
  numNls = 0|(eddyIndex / 32);
  outRange[1] = startOfData + eddyIndex * 4 + numNls;
  return outRange;
}

/* Parse out an eddy from the text stream at the given position.  */
function getEddy(outEddy, index) {
  var numNls = 0|(index / 32);
  var curPos = startOfData + index * 4 + numNls;

  // Start by reading the raw data fields.
  outEddy[0] = 0; // Eddy type
  outEddy[1] = textBuf.charCodeAt(curPos++); // Latitude
  outEddy[2] = textBuf.charCodeAt(curPos++); // Longitude
  outEddy[3] = textBuf.charCodeAt(curPos++); // Next
  outEddy[4] = textBuf.charCodeAt(curPos++); // Prev

  // Perform mandatory format conversions.
  for (var i = 1, len = outEddy.length; i < len; i++) {
    if (outEddy[i] == INPUT_ZERO_SYM)
      outEddy[i] = 0;
    else if (outEddy[i] > 0xd7ff)
      outEddy[i] -= 0x0800;
  }

  // Decode the data fields.
  outEddy[0] = (outEddy[1] >> 14) & 1;
  outEddy[1] = ((outEddy[1] & 0x3fff) - (1 << 13)) / (1 << 6);
  outEddy[2] = ((outEddy[2] & 0x7fff) - (1 << 14)) / (1 << 6);
  return outEddy;
}

/* TODO:

   * Viable implementation of a partial downloader.

Although I was thinking of implementing a generic mmap() JavaScript
module for byte/character oriented datastreams, I am deciding against
this for the web viewer upon the assumption that performance would be
better otherwise.  Maybe.  Data download is only efficient if it is
done in reasonably large chunks.  Also, seeking to lots of random
access locations on is ineficient due to the number of HTTP requests
that have to be issued.  Then again, the exact same things can be said
about hard drives, and it is up to the operating system to provide a
reasonably optimized abstraction layer.

Thus, I changed my mind once again.  My functions will provide for a
full optimizing abstraction layer and generic code on mmap caching.
Note, however, that the size of the mmap cache must be user
controlled, as the Web API provides no way for web applications to
figure out how well a program is doing memory-wise.

There's one caveat, though: Programs must make block alignment
requests with the library.  This will facilitate efficient retrieval
from user JavaScript code.  (Big win: block alignment requests for
starts of date indexes.)  Programs must also use iterator contexts to
access memory, in order for memory accesses to be reasonably fast.

Once memory is box structured inside the library, it cannot be
restructured.  JavaScript is assumed to be too inefficient for this.
Rather, the chunk in question muts be XMLHttpRequested with the proper
alignments.

ChunkAlignSize (default one element), OptimalChunkStarts

Implement joining?  Chunk splitting okay?  Or redownload entire chunk?
All customizable.  Max. number of chunks?  (Avoid array overhead.)

Join threshold, concat, min block size

Define file structure nobreak points.  Complicated...

Need header first.

*/

/*

In the PVS traversal, eddies are primarily referenced by their
indexes.  To read the value of an index, we must use getEddy() above.
In the real code, getEddy() will be an inline function.  Maybe.  It
might be more than fast enough to use as non-inline, though.

curdim = depth % 2;
median = start + (0|((length - 1) / 2));
getEddy(curEddy);
medianVal = curEddy[1+curdim];

How to box split efficiently:

Start by splitting into two boxes if wrap beyond edges.  Don't need to
do this anymore: our algorithm handles wraparound boxes directly.

Maybe it might be a good idea to separate the wraparound box testing
logic into a separate function, though.

Or clip to latitude edge

Divide up box into 4 subboxes if go through major divisions

Use variables instead of arrays as much as possible, for performance.

var vbox = new Array(4);
if (vbox[0] < -90) vbox[0] = -90;
if (vbox[2] > 90) vbox[2] = 90;
if (vbox[1] < -180 && vbox[3] > 180)
  { vbox[1] = -180; vbox[3] = 180; }
// Split the vbox into two separate bounding boxes if it crosses the
// 0 or 360 degrees longitude.
if (vbox[1] < -180) {
  vbox2[0] = vbox[0]; vbox2[2] = vbox[2];
  vbox2[1] = 360 + vbox[1]; vbox2[3] = 180;
  vbox[1] = -180;
}
if (vbox[3] > 180) {
  vbox2[0] = vbox[0]; vbox2[2] = vbox[2];
  vbox2[3] = vbox[3] - 360; vbox2[1] = -180;
  vbox[3] = 180;
}

Run kdPVS twice for above division.

(y - y0) = m(x - x0)
(y - y0) = (y1 - y0)(x - x0) / (x1 - x0)
(x1 - x0)(y - y0) - (y1 - y0)(x - x0) = 0
(y0 - y1)x + (x1 - x0)y - y0(x1 - x0) + x0(y1 - y0) = 0

ax + by + c = 0

a = (y0 - y1)
b = (x1 - x0)
c = x0y1 - y0x1

(1, 5) (3, 2)

m = (5 - 2) / (1 - 3) = 3 / -2 = -3/2
y = -3/2*x + b
5 = -3/2 + b
b = 5 + 3/2 = 13/2
y = -3/2*x + 13/2

a = 5 - 2 = 3
b = 3 - 1 = 2
c = 1*2 - 5*3 = 2 - 15 = -13
3x + 2y - 13 = 0
2y = -3x + 13
3x + 2y - 13 = 0

When the vbox fits entirely in the left or right halves, keep
down traversing as normal.

When the vbox crosses through the median, you must divide the vbox
and traverse both sides.

If the kdvbox is entirely within the vbox, then stop traversing.

If the length is too short, you must stop dividing.

Interesting...

http://earth.usc.edu/~stott/Catalina/Oceans.html

*/

/*

Note: In addition to only rendering what is in the user's view, when
at low zoom levels, the algorithms should proceed to rendering the
rest of the map at the current zoom level, to enable fast scrolling of
the map.

Another option that is important to consider is SVG.  This could
possibly be better than HTML Canvas, considering that in some browsers
(i.e. Firefox), Canvas API calls have a considerable overhead
associated with them.

Maybe its a deal: Prioritized rendering of the local view followed by
rendering of the "scroll" view.  Only render the scroll view at
1440x720 resolution.

Don't use "tournament" selection of the user rendering option.  This
will not result in a good user experience when the rendering options
are automatically switched for hypothesis testing with vigilance.

UI Rendering mechanisms:

* 1. Full-scale canvas render.

* 2. Local-only canvas render.

* 3. SVG render.

All mechanisms must be coded.  User-selection of one mechanism over
another will be enabled based off of the user's browser capabilities.

*/

// Create a list of track bounding boxes, latitude, longitude, and
// date index.  When a certian date index passes, then erase the
// track.  Don't redraw other tracks unless there are bounding
// box intersections.

// Check if a line is contained within a bounding box.  Note that for
// this algorithm, we exclude lines that only touch the outside of the
// box, but don't go through it.

// line and vbox must be [ minLat, minLon, maxLat, maxLon ]
function lineIntersect(line, vbox) {
  var vbox_min_x = vbox[1], vbox_min_y = vbox[0];
  var vbox_max_x = vbox[3], vbox_max_y = vbox[2];
  var p1_x = line[1], p1_y = line[0];
  var p2_x = line[3], p2_y = line[2];

  // Check if either of the line's points are entirely within the
  // bounding box.  We will know for sure the line is visible.

  if ((vbox_min_x < p1_x && p1_x < vbox_max_x &&
       vbox_min_y < p1_y && p1_y < vbox_max_y) ||
      (vbox_min_x < p2_x && p2_x < vbox_max_x &&
       vbox_min_y < p2_y && p2_y < vbox_max_y))
    return true;

  // ax + by + c = 0
  var a = p1_y - p2_y;
  var b = p2_x - p1_x;
  var c = p1_x * p2_y - p1_y * p2_x;

  // y = -(ax + c) / b
  // x = -(by + c) / a

  // Compute the intersections.
  var vbox_min_y_ict = (a != 0) ? (-(b * vbox_min_y) / a) : vbox_max_x * 2;
  var vbox_max_y_ict = (a != 0) ? (-(b * vbox_max_y) / a) : vbox_max_x * 2;
  var vbox_min_x_ict = (b != 0) ? (-(a * vbox_min_x) / b) : vbox_max_y * 2;
  var vbox_max_x_ict = (b != 0) ? (-(a * vbox_max_x) / b) : vbox_max_y * 2;
  if ((vbox_min_x < vbox_min_y_ict && vbox_min_y_ict < vbox_max_x) ||
      (vbox_min_x < vbox_max_y_ict && vbox_max_y_ict < vbox_max_x) ||
      (vbox_min_y < vbox_min_x_ict && vbox_min_x_ict < vbox_max_y) ||
      (vbox_min_y < vbox_max_x_ict && vbox_max_x_ict < vbox_max_y))
    return true;
  return false;
}

/* Kd-tree potential visibility traversal.  This function traverses
   the kd-tree at the current date to determine the smallest kd-tree
   cell that entirely contains the viewport bounding box.

   Sometimes the viewport box will cross upper level kd-tree divisions
   that would cause it to have to include an excessively large PVS
   boundary.  For these cases, the bounding box can be subdivided up
   to 4 times to avoid worst cases of this scenario.

   curDate: Current date index
   vbox: [ minLat, minLon, maxLat, maxLon ]
   Units are degrees.

   FIXME:
   Better code organization.
   Separate definitely visible and possibly visible results pushing.

   Build a complement array of non-prioritized regions.

   To build: Simply put, during traversal, put paths not taken as
   ranges in this tree.

   Return an array of three arrays in the following order:

   [ definitely_visible, possibly_visible, not_visible ]

   Referring to the eddies in the current date, not the visibility of
   the tracks.

*/
function kdPVS(curDate, vbox) {
  var curEddy = new Array(5);

  var stack = [];
  var results = [];
  var numSplits = 0;
  var numTrims = 0;

  var kdVbox = [ -90, -180, 90, 180 ];
  var start = dateChunkStarts[curDate];
  var length = dateChunkStarts[curDate+1] - dateChunkStarts[curDate];
  var depth = 0;

  while (length > 0) {
    // Current dimension (latitude (0) or longitude (1))
    var curdim = depth % 2;
    var median = start + (0|((length - 1) / 2));
    var end = start + length;
    getEddy(curEddy, median);
    var medianVal = curEddy[1+curdim];
    var vbox_min = vbox[curdim];
    var vbox_max = vbox[2+curdim];
    var vbox_order = vbox_max - vbox_min;
    if (length > 1 &&
        ((vbox_order > 0 &&
          vbox_min < medianVal && vbox_max < medianVal) ||
         (vbox_order < 0 &&
          kdVbox[2+curdim] < vbox_min &&
          medianVal > vbox_max))) {
      // Choose the less-than side.
      kdVbox[2+curdim] = medianVal;
      /* start = start; */ length = median - start; depth++;
      numTrims++;
    } else if (length > 1 &&
               ((vbox_order > 0 &&
                 vbox_min > medianVal && vbox_max > medianVal) ||
                (vbox_order < 0 &&
                 kdVbox[curdim] > vbox_max &&
                 medianVal < vbox_min))) {
      // Choose the greater-than side.
      kdVbox[curdim] = medianVal;
      start = median + 1; length = end - start; depth++;
      numTrims++;
    } else {
      /* Split the traversal box into two boxes if the traversal box
         does not fit entirely within the viewport box.  */

      // If the traversal box's edges exceed the edges of the viewport box
      // by one width or there are too many points within the traversal
      // box (thus potentially outside the viewport box), definitely
      // consider splitting it.

      // Split this into two boxes if the dimensions are oversized
      // by a factor of 4, and the maximum number of splits has
      // not been exceeded.
      // Note: numSplits was 3 and stack.length was 1

      var vbox_latsz = vbox[2] - vbox[0];
      var vbox_lonsz = vbox[3] - vbox[1];

      // Guarantee at least 80 times faster. C * lg n.

      // If this isn't fast enough, then the speed can be increased
      // even further by using 12 and 3 instead.  3 and 1 is too
      // small to be very useful.

      if (length > 1 &&
          (numSplits < 25 && stack.length <= 4) &&
          ((vbox[3] - vbox[1] > 0 && (length > 128 ||
           (vbox[0] - kdVbox[0] > vbox_latsz * 1 ||
            kdVbox[2] - vbox[2] > vbox_latsz * 1 ||
            vbox[1] - kdVbox[1] > vbox_lonsz * 1 ||
            kdVbox[3] - vbox[3] > vbox_lonsz * 1))) ||
           ((vbox[3] - vbox[1] < 0 && (length > 128 ||
            vbox[0] - kdVbox[0] > vbox_latsz * 1 ||
            kdVbox[2] - vbox[2] > vbox_latsz * 1 ||
            kdVbox[3] - vbox[3] < 360 + vbox_lonsz * 1 ||
            vbox[1] - kdVbox[1] < 360 + vbox_lonsz * 1 )))
           ) &&
          /* (kdVbox[2] - kdVbox[0] > (vbox[2] - vbox[0]) * 1 ||
           kdVbox[3] - kdVbox[1] > (vbox[3] - vbox[1]) * 1) && */
          !(vbox_order > 0 &&
            kdVbox[0] > vbox[0] && kdVbox[2] < vbox[2] &&
            kdVbox[1] > vbox[1] && kdVbox[3] < vbox[3]) &&
          !(vbox[3] - vbox[1] < 0 &&
            ((kdVbox[1] < vbox[3] && kdVbox[3] < vbox[3]) ||
             (kdVbox[1] > vbox[1] && kdVbox[3] > vbox[1])) &&
            kdVbox[0] > vbox[0] && kdVbox[2] < vbox[2])) {

        // Include the median if it is within the viewport box.
        if (vbox[3] - vbox[1] > 0 &&
            vbox[0] < curEddy[1] && curEddy[1] < vbox[2] &&
            vbox[1] < curEddy[2] && curEddy[2] < vbox[3])
          results.push([ median, 1 ]); // DEFINITELY VISIBLE
        if (vbox[3] - vbox[1] < 0 &&
            (curEddy[2] < vbox[3] || curEddy[2] > vbox[1]) &&
            vbox[0] < curEddy[1] && curEddy[1] < vbox[2])
          results.push([ median, 1 ]); // DEFINITELY VISIBLE

        numSplits++; depth++;
        var frame = new Array(4);
        frame[0] = kdVbox.slice(0);     // kdVbox
        frame[0][2+curdim] = medianVal;
        frame[1] = start;               // start
        frame[2] = median - start;      // length
        frame[3] = depth;               // depth
        stack.push(frame);

        kdVbox[curdim] = medianVal;
        start = median + 1; length = end - start;
      } else if (length <= 1) {
        // Cannot split a partition of minimum size.
        if (length == 1 &&
            vbox[0] < curEddy[1] && curEddy[1] < vbox[2] &&
            vbox[1] < curEddy[2] && curEddy[2] < vbox[3])
          results.push([ start, length ]); // DEFINITELY VISIBLE
        if (length == 1 && vbox[3] - vbox[1] < 0 &&
            (curEddy[2] < vbox[3] || curEddy[2] > vbox[1]) &&
            vbox[0] < curEddy[1] && curEddy[1] < vbox[2])
          results.push([ median, 1 ]); // DEFINITELY VISIBLE
        length = 0; // Force popping from the stack.
      } else {
        // This box is entirely within the viewport box.
        // Or, the above check simply pruned the box due to
        // algorithm runtime and stepping limits.
        results.push([ start, length ]); // Possibly visible.
        length = 0; // Force popping from the stack.
      }
    }

    // Process any entries remaining on the stack.
    while (length == 0 && stack.length > 0) {
      var frame = stack.pop();
      kdVbox = frame[0];
      start = frame[1]; length = frame[2]; depth = frame[3];
    }
  }
  // alert('' + numSplits + ' ' + numTrims);
  return results;
}

/*

/Prioritized/ rendering: Sort the definitely visible ranges to the
front of a range rendering array, then append the remaining ranges
onto the end.  Process the entire array to render.

Check how many eddies are within a cell.  If there are a lot of eddies
in a cell AND it is oversized, then try to break it up.  Otherwise,
leave it.

Need a separate list of ranges definitely within the view, i.e. no
linear vis testing necessary.

MAKE SURE to match min and max correctly before sending to the
algorithm!

*/

// Recursively draw a kd-tree's structure.
function kdRender(curDate, canvas, scale, ranges, maxDepth) {
  var curEddy = new Array(5);
  var ctx = canvas.getContext("2d");
  ctx.strokeStyle = "#800080";

  var stack = [];
  var kdVbox = [ -90, -180, 90, 180 ];
  var start = dateChunkStarts[curDate];
  var length = dateChunkStarts[curDate+1] - dateChunkStarts[curDate];
  var depth = 0;

  while (length > 0) {
    // Current dimension (latitude (0) or longitude (1))
    var curdim = depth % 2;
    var median = start + (0|((length - 1) / 2));
    var end = start + length;
    getEddy(curEddy, median);
    var medianVal = curEddy[1+curdim];

    if ((!maxDepth || depth < maxDepth)) {
      if (!ranges)
        ctx.strokeStyle = "#800080";
      else {
        ctx.strokeStyle = "#000000";
        for (var i = 0, ranges_length = ranges.length;
             i < ranges_length; i++) {
          if (median >= ranges[i][0] &&
              median < ranges[i][0] + ranges[i][1])
            ctx.strokeStyle = "#800080";
        }
      }
      ctx.beginPath();
      if (curdim == 0) {
        ctx.moveTo((kdVbox[1] + 180) * scale, (-medianVal + 90) * scale);
        ctx.lineTo((kdVbox[3] + 180) * scale, (-medianVal + 90) * scale);
      } else {
        ctx.moveTo((medianVal + 180) * scale, (-kdVbox[0] + 90) * scale);
        ctx.lineTo((medianVal + 180) * scale, (-kdVbox[2] + 90) * scale);
      }
      var xcenter = (curEddy[2] + 180) * scale;
      var ycenter = (-curEddy[1] + 90) * scale;
      ctx.moveTo(xcenter + 2, ycenter);
      ctx.arc(xcenter, ycenter, 2, 0, 2 * Math.PI, false);
      ctx.stroke();
    }

    depth++;
    var frame = new Array(4);
    frame[0] = kdVbox.slice(0);
    frame[0][2+curdim] = medianVal;
    frame[1] = start;               // start
    frame[2] = median - start;      // length
    frame[3] = depth;               // depth
    stack.push(frame);

    kdVbox[curdim] = medianVal;
    start = median + 1; length = end - start;

    while (length == 0 && stack.length > 0) {
      var frame = stack.pop();
      kdVbox = frame[0];
      start = frame[1]; length = frame[2]; depth = frame[3];
    }
  }
}

function drawVBox(canvas, scale, initVbox) {
  var vbox = initVbox.slice(0);
  vbox[0] = (-vbox[0] + 90) * scale;
  vbox[2] = (-vbox[2] + 90) * scale;
  vbox[1] = (vbox[1] + 180) * scale;
  vbox[3] = (vbox[3] + 180) * scale;
  var ctx = canvas.getContext("2d");
  ctx.strokeStyle = "#ff0000";
  // ctx.lineWidth = 2;
  ctx.beginPath();
  if (vbox[1] < vbox[3])
    ctx.rect(vbox[1], vbox[0],
		   vbox[3] - vbox[1], vbox[2] - vbox[0]);
  else {
    ctx.moveTo(0, vbox[0]);
    ctx.lineTo(vbox[3], vbox[0]);
    ctx.lineTo(vbox[3], vbox[2]);
    ctx.lineTo(0, vbox[2]);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(360 * scale, vbox[0]);
    ctx.lineTo(vbox[1], vbox[0]);
    ctx.lineTo(vbox[1], vbox[2]);
    ctx.lineTo(360 * scale, vbox[2]);
  }
  ctx.stroke();
}

// Convenience function for in-browser testing.
function testKdWithParams(scale, vbidx, curDate) {
  kdDbg.width = 360 * scale;
  kdDbg.height = 180 * scale;
  // var ctx = kdDbg.getContext("2d");
  // ctx.clearRect(0, 0, kdDbg.width, kdDbg.height);
  var pvsResults = kdPVS(curDate, exampleVboxes[vbidx]);
  kdRender(curDate, kdDbg, scale, pvsResults);
  drawVBox(kdDbg, scale, exampleVboxes[vbidx]);
}

// Generate a downloadable static HTML page.
function generateStaticPage(event) {
  // Remove/replace troublesome elements from the page.  That includes
  // script elements.
  var slParent = genSLink.parentNode;
  body.removeChild(binDisplay);
  body.removeChild(slParent);
  body.removeChild(kdDbg);
  var staticImage = new Image(kdDbg.width, kdDbg.height);
  staticImage.src = kdDbg.toDataURL();
  body.appendChild(staticImage);
  var sEBTN = API.getEBTN('script', body);
  var scriptEls = new Array();
  for (var i = 0, se_len = sEBTN.length; i < se_len; i++)
    scriptEls.push(sEBTN[i]);
  for (var i = 0, se_len = scriptEls.length; i < se_len; i++)
    body.removeChild(scriptEls[i]);

  { // Remove any injected scripts (i.e. Firebug).
    var docEl = document.documentElement;
    var sEBTN = API.getEBTN('script');
    var injScriptEls = new Array();
    for (var i = 0, se_len = sEBTN.length; i < se_len; i++)
      injScriptEls.push(sEBTN[i]);
    var sEBTN = API.getEBTN('html:script');
    for (var i = 0, se_len = sEBTN.length; i < se_len; i++)
      injScriptEls.push(sEBTN[i]);
    for (var i = 0, se_len = injScriptEls.length; i < se_len; i++) {
      var parentNode = injScriptEls[i].parentNode;
      parentNode.removeChild(injScriptEls[i]);
    }
  }

  // NOTE: Since Internet Explorer cannot navigate to Data URIs,
  // this function will not work in Internet Explorer as-is.
  var doctype = document.doctype;
  var dtstr = [ "<!DOCTYPE ", doctype.name,
                " PUBLIC \"", doctype.publicId,
                "\"\n  \"", doctype.systemId, "\">" ].join('');
  var docHtml = [ dtstr,
    API.getElementOuterHtml(document.documentElement, true) ].join('\n');
  var downloadText = [
    "data:application/octet-stream;charset=utf-8;base64,",
    btoa(docHtml) ].join('');

  // Add removed elements back to the page after the static version
  // has been generated.
  body.removeChild(staticImage);
  body.appendChild(kdDbg);
  body.appendChild(slParent);
  body.appendChild(binDisplay);
  for (var i = 0, se_len = scriptEls.length; i < se_len; i++)
    body.appendChild(scriptEls[i]);

  // window.location = downloadText;
  genSLink.href = downloadText;

  return true;
}

function processTestFile() {
  if (httpRequest.readyState === 4) {
    if (httpRequest.status === 200) {
      body = API.getBodyElement();
      textBuf = new String(httpRequest.responseText);
      var textBuf_length = textBuf.length;

      // Start by skipping past the human-readable header.
      var re = /(^|\n)# BEGIN_DATA\n/g;
      if (!re.exec(textBuf))
        return; // Invalid data file.
      var curPos = re.lastIndex;

      /* Read the format header.  */
      var formatBits = textBuf.charCodeAt(curPos++);
      if (formatBits & 0x02) /* Extended range */
        INPUT_ZERO_SYM = 0xffff;
      else
        INPUT_ZERO_SYM = 0xd7ff;
      if (formatBits & 0x04) /* Track-keyed format */
        ;
      else
        /* Eddy-keyed format */;

      // Read the entire dates header.
      var numDates = textBuf.charCodeAt(curPos++);
      var lastCumDates = 0;
      dateChunkStarts.push(lastCumDates);
      for (var i = 0; i < numDates; i++) {
        if (i % 32 == 0)
          curPos++; // Skip the newline character.
        var numEddies = textBuf.charCodeAt(curPos++);
        eddiesPerDate.push(numEddies);
        lastCumDates += numEddies;
        dateChunkStarts.push(lastCumDates);
      }
      curPos++; // Skip the newline immediately at the end of the header.
      startOfData = curPos;
      // console.log(eddiesPerDate);
      // dispArray(dateChunkStarts);

      /* Rather than parsing out all data into JavaScript objects at
         this point, we will only parse out the data when we need it.
         Advantage: This is a tremendous economization on memory
         consumption: Using only a single JavaScript object for
         multiple entities results in far less garbage accumulation.
         Plus, this method allows us to count the exact number of
         bytes of memory that our JavaScript program needs.  */

      /* NOTE: Arrays are sometimes slow on old JS runtimes and should
         be avoided.  However, it appears that small arrays used in
         this manner may not be problematic.  */
      var curEddy = new Array(5);
      var startIdx = 0;
      var nextIdx = startIdx;

      for (var i = 0; i < 10; i++) {
        getEddy(curEddy, nextIdx);
        dispArray(curEddy);
        var next = curEddy[3];
        nextIdx += next;
        if (next == 0)
          nextIdx = ++startIdx;
      }

      var vbox = exampleVboxes[10];
      var pvsResults = kdPVS(0, vbox);
      /* for (var i = 0, pvsRes_len = pvsResults.length; i < pvsRes_len; i++)
        dispArray(pvsResults[i]); */

      // First create a drawing canvas.
      kdDbg = document.createElement("canvas");
      kdDbg.width = 360 * 4;
      kdDbg.height = 180 * 4;
      body.appendChild(kdDbg);
      kdRender(0, kdDbg, 4, pvsResults);
      drawVBox(kdDbg, 4, vbox);

      /* Note: One possibly useful technique is to keep the entire
         data string in memory, but only keep a small window of
         the data parsed into a format useful for JavaScript.  This
         will alleviate the issue of garbage accumulation.  */
      /* Memory allocation problem solved: Buffering.  The old format
         tended toward arrays that had way too many elements for the
         JavaScript runtime to be happy.  That's why everything ran
         so slow and consumed so much memory.  Also, the singly-linked
         lists format is a dud: the numbers do indeed get too large
         for it to work.  */

      // Provide a link to generate a static version of the page.
      var slParent = document.createElement('p');
      genSLink = document.createElement('a');
      genSLink.href = "#generateStaticPage";
      genSLink.innerHTML = 'Download a static version of this page.';
      genSLink.download = 'wctest.html';
      genSLink.onclick = generateStaticPage;
      slParent.appendChild(genSLink);
      body.appendChild(slParent);

      /* This test is bound to create serious problems with most
         browsers on most computers.  Thus, we limit the number of
         characters displayed to 4096.  */
      dispDiag(textBuf.substr(0, 4096), body);

      // console.log("Done processing.");
      alert("Done processing.");

      // Cleanup
      /* None of these deletes will succeed, though, since all of the
         variables were declared with `var'.  */
      delete httpRequest;
      delete textBuf;
      delete INPUT_ZERO_SYM;
      delete eddiesPerDate;
      delete dateChunkStarts;
      delete startOfData;
    } else {
      alert("There was a problem with the request.");
    }
  }
}

// Load the test file.
if (window.XMLHttpRequest) // Mozilla, Safari, ...
  httpRequest = new XMLHttpRequest();
else if (window.ActiveXObject) // IE 8 and older
  httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
  // Plus we would need lots of error handling...
if (!httpRequest) {
  alert("Could not create an XMLHttpRequest.");
  // return;
}
httpRequest.onreadystatechange = processTestFile;
httpRequest.open("GET", "../data/tracks.wtxt", true);
// NOTE: overrideMimeType has compatibility issues.
httpRequest.overrideMimeType("text/plain; charset=utf-16le");
httpRequest.send();

//--><!]]>
</script>

</body>
</html>
