<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>wchar test page</title>
</head>
<body>

<p>This is the wchar test page.  Good luck!</p>

<script type="text/javascript" src="../mylib.js"></script>
<script type="text/javascript">

var httpRequest;

var textBuf;
/* The character code that represents zero in the input.  */
var INPUT_ZERO_SYM;
var eddiesOnDate = [];
var cumDates = [];
var startOfData; // Character offset where eddy records begin.

/*

Array of date records:

[ list of downloaded chunk starts ]
[ list of data strings ]

First request: download linearly.

User seeks to an undownloaded position: abort current request.
Start new request (insert new request chunk)
Download a couple of date indexes in front of request for performance
Keep downloading
When finished, download any missing chunks in between
Always start download at date boundary.

Provision for a time where backwards downloads are requested before
normal downloads.

*/

function dispDiag(diagText) {
  var dispInfo = document.createElement("pre");
  dispInfo.appendChild(document.createTextNode(diagText));
  document.documentElement.children[1].appendChild(dispInfo);
}

function dispArray(array) {
  var length = array.length;
  var diagText = "" + length + ": [ " + array + " ]";
  diagText = diagText.replace(/,/g, ", ");
  var wrapper = document.createElement("p");
  var dispInfo = document.createElement("code");
  dispInfo.appendChild(document.createTextNode(diagText));
  wrapper.appendChild(dispInfo);
  document.documentElement.children[1].appendChild(wrapper);
}

/* Compute the byte range to download for the given date index.  */
function getDate(outRange, index) {
  var eddyIndex = cumDates[index];
  var numNls = 0|(eddyIndex / 32);
  outRange[0] = startOfData + eddyIndex * 4 + numNls;
  eddyIndex = cumDates[index+1];
  numNls = 0|(eddyIndex / 32);
  outRange[1] = startOfData + eddyIndex * 4 + numNls;
  return outRange;
}

/* Parse out an eddy from the text stream at the given position.  */
function getEddy(outEddy, index) {
  var numNls = 0|(index / 32);
  var curPos = startOfData + index * 4 + numNls;

  // Start by reading the raw data fields.
  outEddy[0] = 0; // Eddy type
  outEddy[1] = textBuf.charCodeAt(curPos++); // Latitude
  outEddy[2] = textBuf.charCodeAt(curPos++); // Longitude
  outEddy[3] = textBuf.charCodeAt(curPos++); // Next
  outEddy[4] = textBuf.charCodeAt(curPos++); // Prev

  // Perform mandatory format conversions.
  for (var i = 1, len = outEddy.length; i < len; i++) {
    if (outEddy[i] == INPUT_ZERO_SYM)
      outEddy[i] = 0;
    else if (outEddy[i] > 0xd7ff)
      outEddy[i] -= 0x0800;
  }

  // Decode the data fields.
  outEddy[0] = (outEddy[1] >> 14) & 1;
  outEddy[1] = ((outEddy[1] & 0x3fff) - (1 << 13)) / (1 << 6);
  outEddy[2] = ((outEddy[2] & 0x7fff) - (1 << 14)) / (1 << 6);
  return outEddy;
}

/* TODO:

   * Viable implementation of a partial downloader.

   * Kd-tree traversal for potential visible rendering.

*/

/*

In the PVS traversal, eddies are primarily referenced by their
indexes.  To read the value of an index, we must use getEddy() above.
In the real code, getEddy() will be an inline function.

curdim = depth % 2;
median = start + (0|((length - 1) / 2));
getEddy(curEddy);
medianVal = curEddy[1+curdim];

How to box split efficiently:

Start by splitting into two boxes if wrap beyond edges

Or clip to latitude edge

Divide up box into 4 subboxes if go through major divisions

Use variables instead of arrays as much as possible, for performance.

var vbox = new Array(4);
if (vbox[0] < -90) vbox[0] = -90;
if (vbox[2] > 90) vbox[2] = 90;
if (vbox[1] < -180 && vbox[3] > 180)
  { vbox[1] = -180; vbox[3] = 180; }
// Split the vbox into two separate bounding boxes if it crosses the
// 0 or 360 degrees longitude.
if (vbox[1] < -180) {
  vbox2[0] = vbox[0]; vbox2[2] = vbox[2];
  vbox2[1] = 360 + vbox[1]; vbox2[3] = 180;
  vbox[1] = -180;
}
if (vbox[3] > 180) {
  vbox2[0] = vbox[0]; vbox2[2] = vbox[2];
  vbox2[3] = vbox[3] - 360; vbox2[1] = -180;
  vbox[3] = 180;
}

Run kdPVS twice for above division.

(y - y0) = m(x - x0)
(y - y0) = (y1 - y0)(x - x0) / (x1 - x0)
(x1 - x0)(y - y0) - (y1 - y0)(x - x0) = 0
(y0 - y1)x + (x1 - x0)y - y0(x1 - x0) + x0(y1 - y0) = 0

ax + by + c = 0

a = (y0 - y1)
b = (x1 - x0)
c = x0y1 - y0x1

(1, 5) (3, 2)

m = (5 - 2) / (1 - 3) = 3 / -2 = -3/2
y = -3/2*x + b
5 = -3/2 + b
b = 5 + 3/2 = 13/2
y = -3/2*x + 13/2

a = 5 - 2 = 3
b = 3 - 1 = 2
c = 1*2 - 5*3 = 2 - 15 = -13
3x + 2y - 13 = 0
2y = -3x + 13
3x + 2y - 13 = 0

*/

/* Kd-tree potential visibility traversal.  This function traverses
   the kd-tree at the current date to determine the smallest kd-tree
   cell that entirely contains the viewport bounding box.

   Sometimes the viewport box will cross upper level kd-tree divisions
   that would cause it to have to include an excessively large PVS
   boundary.  For these cases, the bounding box can be subdivided up
   to 4 times to avoid worst cases of this scenario.

   curDate: Current date index
   vbox: [ minLat, minLon, maxLat, maxLon ]
   Units are degrees.

*/
function kdPVS(vbox) {
  var curEddy = new Array(5);

  var stack = [];
  var results = [];
  var numSplits = 0;

  var kdVbox = [ -90, -180, 90, 180 ];
  var start = cumDates[curDate];
  var length = cumDates[curDate+1] - cumDates[curDate];
  var depth = 0;
  var lastStart = start;
  var lastLength = length;

  while (length > 0) {
    var curdim = depth % 2; /* Latitude (0) or longitude (1) */
    var median = start + (0|((length - 1) / 2));
    var end = start + length;
    getEddy(curEddy, median);
    var medianVal = curEddy[1+curdim];
    var vbox_min = vbox[curdim];
    var vbox_max = vbox[2+curdim];
    if (vbox_min < medianVal && vbox_max < medianVal) {
      // Choose the less-than side.
      kdVbox[2+curdim] = medianVal;
      lastStart = start; lastLength = length;
      /* start = start; */ length = median - start;
      depth++;
    } else if (vbox_min > medianVal && vbox_max > medianVal) {
      // Choose the greater-than side.
      kdVbox[curdim] = medianVal;
      lastStart = start; lastLength = length;
      start = median + 1; length = end - start;
      depth++;
    } else {
      // Split this into two boxes if the dimensions are oversized
      // by a factor of 4, and the maximum number of splits has
      // not been exceeded.
      if (numSplits < 4 && stack.length <= 1 &&
          ((vbox[2] - vbox[0] > (kdVbox[2] - kdVbox[0]) * 4) ||
           (vbox[3] - vbos[1] > (kdVbox[3] - kdVbox[1]) * 4))) {
        numSplits++; depth++;
        var frame = new Array(6);
        frame[0] = kdVbox.slice(0);     // kdVbox
        frame[0][2+curdim] = medianVal;
        frame[1] = start;               // start
        frame[2] = median - start;      // length
        frame[3] = depth;               // depth
        frame[4] = start;               // lastStart
        frame[5] = length;              // lastLength
        stack.push(frame);

        kdVbox[curdim] = medianVal;
        lastStart = start; lastLength = length;
        start = median + 1; length = end - start;
      } else {
        // Otherwise, we're done.
        results.push([ lastStart, lastLength ]);
        // Process any entries remaining on the stack.
        if (stack.length > 0) {
          var frame = stack.pop();
          kdVbox = frame[0]; start = frame[1]; length = frame[2];
          depth = frame[3]; lastStart = frame[4]; lastLength = frame[5];
        } else
          return results;
      }
    }
    if (length == 0 && stack.length > 0) {
        var frame = stack.pop();
        kdVbox = frame[0]; start = frame[1]; length = frame[2];
        depth = frame[3]; lastStart = frame[4]; lastLength = frame[5];
    }
  }
}

function processTestFile() {
  if (httpRequest.readyState === 4) {
    if (httpRequest.status === 200) {
      textBuf = new String(httpRequest.responseText);
      var textBuf_length = textBuf.length;

      // Start by skipping past the human-readable header.
      var re = /(^|\n)# BEGIN_DATA\n/g;
      if (!re.exec(textBuf))
        return; // Invalid data file.
      var curPos = re.lastIndex;

      /* Read the format header.  */
      var formatBits = textBuf.charCodeAt(curPos++);
      if (formatBits & 0x02) /* Extended range */
        INPUT_ZERO_SYM = 0xffff;
      else
        INPUT_ZERO_SYM = 0xd7ff;
      if (formatBits & 0x03) /* Track-keyed format */
        ;
      else
        /* Eddy-keyed format */;

      // Read the entire dates header.
      var numDates = textBuf.charCodeAt(curPos++);
      var lastCumDates = 0;
      cumDates.push(lastCumDates);
      for (var i = 0; i < numDates; i++) {
        if (i % 32 == 0)
          curPos++; // Skip the newline character.
        var numEddies = textBuf.charCodeAt(curPos++);
        eddiesOnDate.push(numEddies);
        lastCumDates += numEddies;
        cumDates.push(lastCumDates);
      }
      curPos++; // Skip the newline immediately at the end of the header.
      startOfData = curPos;
      // console.log(eddiesOnDate);
      // console.log(cumDates);
      // dispArray(cumDates);

      /* Rather than parsing out all data into JavaScript objects at
         this point, we will only parse out the data when we need it.
         Advantage: This is a tremendous economization on memory
         consumption: Using only a single JavaScript object for
         multiple entities results in far less garbage accumulation.
         Plus, this method allows us to count the exact number of
         bytes of memory that our JavaScript program needs.  */

      /* NOTE: Arrays are sometimes slow on old JS runtimes and should
         be avoided.  However, it appears that small arrays used in
         this manner may not be problematic.  */
      var curEddy = []; curEddy.length = 5 >>> 0;
      var startIdx = 0;
      var nextIdx = startIdx;

      for (var i = 0; i < 10; i++) {
        getEddy(curEddy, nextIdx);
        dispArray(curEddy);
        var next = curEddy[3];
        nextIdx += next;
        if (next == 0)
          nextIdx = ++startIdx;
      }

      var kdDbg = document.createElement("canvas");
      kdDbg.width = 360 * 4;
      kdDbg.height = 180 * 4;
      document.documentElement.children[1].appendChild(kdDbg);
      var ctx = kdDbg.getContext("2d");
      ctx.strokeStyle = "#800080";
      { // Try recursively drawing a kd-tree.
        var i = 3;
        var stack = [];
        var kdVbox = [ -90, -180, 90, 180 ];
        var start = cumDates[i];
        var length = cumDates[i+1] - cumDates[i];
        var depth = 0;
        var lastStart = start;
        var lastLength = length;

        while (length > 0) {
          var curdim = depth % 2; /* Latitude (0) or longitude (1) */
          var median = start + (0|((length - 1) / 2));
          var end = start + length;
          getEddy(curEddy, median);
          var medianVal = curEddy[1+curdim];

          if (true /* depth < 5 */) {
            ctx.beginPath();
            if (curdim == 0) {
              ctx.moveTo((kdVbox[1] + 180) * 4, (-medianVal + 90) * 4);
              ctx.lineTo((kdVbox[3] + 180) * 4, (-medianVal + 90) * 4);
            } else {
              ctx.moveTo((medianVal + 180) * 4, (-kdVbox[0] + 90) * 4);
              ctx.lineTo((medianVal + 180) * 4, (-kdVbox[2] + 90) * 4);
            }
            ctx.stroke();
            ctx.beginPath();
            ctx.arc((curEddy[2] + 180) * 4, (-curEddy[1] + 90) * 4,
                    2, 0, 2 * Math.PI, false);
            ctx.stroke();
          }

          depth++;
          var frame = new Array(6);
          frame[0] = kdVbox.slice(0);
          frame[0][2+curdim] = medianVal;
          frame[1] = start;               // start
          frame[2] = median - start;      // length
          frame[3] = depth;               // depth
          frame[4] = start;               // lastStart
          frame[5] = length;              // lastLength
          stack.push(frame);

          kdVbox[curdim] = medianVal;
          lastStart = start; lastLength = length;
          start = median + 1; length = end - start;

          while (length == 0 && stack.length > 0) {
            var frame = stack.pop();
            kdVbox = frame[0]; start = frame[1]; length = frame[2];
            depth = frame[3]; lastStart = frame[4]; lastLength = frame[5];
          }
        }
      }

      /* Note: One possibly useful technique is to keep the entire
         data string in memory, but only keep a small window of
         the data parsed into a format useful for JavaScript.  This
         will alleviate the issue of garbage accumulation.  */
      /* Memory allocation problem solved: Buffering.  The old format
         tended toward arrays that had way too many elements for the
         JavaScript runtime to be happy.  That's why everything ran
         so slow and consumed so much memory.  Also, the singly-linked
         lists format is a dud: the numbers do indeed get too large
         for it to work.  */

      /* This test is bound to create serious problems with most
         browsers on most computers.  Thus, we limit the number of
         characters displayed to 4096.  */
      dispInfo = document.createElement("pre");
      dispInfo.appendChild(document.
        createTextNode(textBuf.substr(0, 4096)));
      document.documentElement.children[1].appendChild(dispInfo);

      // console.log("Done processing.");
      alert("Done processing.");

      // Generate a downloadable static HTML page.
      /* var doctype = document.doctype;
      var dtstr = [ "<!DOCTYPE ", doctype.name,
                    " PUBLIC \"", doctype.publicId,
                    "\"\n  \"", doctype.systemId, "\">" ].join('');
      var docHtml = [ dtstr,
        API.getElementOuterHtml(document.documentElement) ].join('\n');
      var downloadText = [ "data:text/html;charset=utf-8;base64,",
        btoa(docHtml) ].join('');

      window.location = downloadText; */

      // Cleanup
      delete httpRequest;
      delete INPUT_ZERO_SYM;
      delete eddiesOnDate;
      delete cumDates;
      delete startOfData;
    } else {
      alert("There was a problem with the request.");
    }
  }
}

// Load the test file.
if (window.XMLHttpRequest) // Mozilla, Safari, ...
  httpRequest = new XMLHttpRequest();
else if (window.ActiveXObject) // IE 8 and older
  httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
  // Plus we would need lots of error handling...
if (!httpRequest) {
  alert("Could not create an XMLHttpRequest.");
  // return;
}
httpRequest.onreadystatechange = processTestFile;
httpRequest.open("GET", "../data/tracks.wtxt", true);
// NOTE: overrideMimeType has compatibility issues.
httpRequest.overrideMimeType("text/plain; charset=utf-16le");
httpRequest.send();

</script>

</body>
</html>
